<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[FrozenMoon]]></title>
  <subtitle><![CDATA[game,cat]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://frozenmoon.github.io/"/>
  <updated>2015-08-18T12:41:08.572Z</updated>
  <id>http://frozenmoon.github.io/</id>
  
  <author>
    <name><![CDATA[FrozenMoon]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从vs2005升级到vs2013]]></title>
    <link href="http://frozenmoon.github.io/2015/08/18/vs2005%E5%8D%87%E7%BA%A7vs2013/"/>
    <id>http://frozenmoon.github.io/2015/08/18/vs2005升级vs2013/</id>
    <published>2015-08-18T08:20:43.000Z</published>
    <updated>2015-08-18T12:41:08.572Z</updated>
    <content type="html"><![CDATA[<p>由于历史的原因，项目一直在使用vs2005进行开发，据说其他老一点的游戏项目很多也用05的，包括WOW，大概是因为05年正好是端游最火爆时期吧。<br>但是都过去10年了，是时候拥抱一下新的东西了:D。</p>
<p>最近不是很忙，就把之前一直想做的这件事情做了。花了两周的时间，算是基本升级完成了。<br>升级的过程中遇到各种问题，还是挺有意思的。</p>
<a id="more"></a>
<hr>
<h2 id="准备">准备</h2><p>说起来惭愧，工作两年多还没有系统的了解过项目的工程结构，趁这个机会也可以系统的了解下。<br>结果着实吓了一跳，单是solution就有5个，project大大小小有上百个。当然了，实际用到的没有这么多 ，有部分的是以前用的工具或者已经废弃的功能。<br>由于我们平时开发都是在window上进行的，包括server也是自己编译用来单服测试，所以就存在一套linux编译的工具链，这部分成了升级的头疼问题。</p>
<p>大概了解了一下vs2013的工程构建体系，在vs2010之后微软大改了一次构建体系，使用<strong>MSBuild</strong>系统来构建vs项目，和之前的差别还是挺大的。<br>比如05的工程后缀名是<strong>vcproj</strong>，而13的是<strong>vcxpro</strong>。之后比较了一下同样一个工程下这两种格式，发现后者比前者精简不少，确实进步了。<br>还有不得不说下MSDN的资料越来越周全了，包括vs2013工程的各种参数解释都有，还有常见的warming和error的解决方法。</p>
<p>开始之前整理了一下几个目标点：</p>
<ul>
<li>保持原来的工程结构，也就是满足同时用05和13进行开发</li>
<li>尽量少的代码改动，防止出现bug</li>
<li>梳理工程间关联</li>
<li>修改版本发布工具（未完成）</li>
</ul>
<hr>
<h2 id="开始">开始</h2><p>首先先复制一份sln，改名字，用13打开，再自动让它自动转换一下。<br>既然是自动转换，肯定是会有问题的，建议工程比较多的时候不要转换后就直接编译solution，而是从耦合度较小的工程开始一个个编译。<br>而且是每个工程都要过一遍，因为vs的自动转换非常不靠谱！</p>
<p>&lt; 顺序可能是：Local lib —-&gt; 3rd lib —-&gt; local dll —-&gt; local exe。local表示自己编写的工程。</p>
<p>我们的client相对server来说，引用的lib比较多，那就先从client开始吧，难的骨头先啃掉。而client不仅仅就是一个exe，还包括各种dll，大概数了一下相关工程有30+，杯具的是我开始做的时候没想到要上InCrediBuild，导致花在编译上的时间就很多了(哭)。建议有条件的还是早早上InCrediBuild吧，能节省不少时间，13的编译速度相对05来说还是慢了一点的。<br>在这里挑出几个值得注意的点说一下：</p>
<h3 id="兼容xp及以上的系统。">兼容xp及以上的系统。</h3><p>开始我并没有注意到这个严重的问题，后来在xp上测试的时候才发现之前一直没考虑到，所以走了一点弯路了。<br>解决方式已有很多现成的了，知乎这个回答得比较全 <a href="http://www.zhihu.com/question/25415940" target="_blank" rel="external">http://www.zhihu.com/question/25415940</a></p>
<p>可能你会遇到下面这些问题：</p>
<pre><code>warning C4005: <span class="string">'__useHeader'</span> : macro redefinition
C/C<span class="subst">++</span> <span class="subst">-&gt; </span>Preprocessor<span class="subst">-&gt; </span>add <span class="subst">-&gt; </span>_USING_V110_SDK71_; 

warning MSB8030: The linker switch <span class="string">"Minimum Required Version"</span> requires <span class="string">"SubSystem"</span> <span class="keyword">to</span> be <span class="built_in">set</span>
Linker <span class="subst">-&gt; </span>System <span class="subst">-&gt; </span>Minimum Required Version <span class="subst">-&gt; </span><span class="number">5.01</span>;
Linker <span class="subst">-&gt; </span>System <span class="subst">-&gt; </span>SubSystem <span class="subst">-&gt; </span>windows（<span class="literal">or</span> concole 要看你的工程性质）
</code></pre><p>还有其他的就不一一列举了，大部分都可以通过google解决，千万不要用baidu。<br>这里最有用的技巧是善用<strong>Preprocessor</strong>（预编译宏）。在工程里设置好之后就不用在代码里面写死了，方便管理。</p>
<h3 id="重新编译第三方库">重新编译第三方库</h3><p>其实local lib的问题还好解决，但是一些3rd lib就有点麻烦了。因为升级得首先保证稳定性，不能随意升级，比如：</p>
<pre><code>boost: Unknown compiler <span class="built_in">version</span> - please run <span class="operator">the</span> configure tests <span class="operator">and</span> report <span class="operator">the</span> results
在<span class="built_in">include</span>\boost\config\compiler\visualc.hpp这个文件可以看到条信息是怎么产生的，
还是由于我们使用的boost库版本太老了。
只好去取了一下最新的boost库的这个文件来修改，支持vs2013的编译就好了。

还有Protobuf，需要重新编译出lib，另外还得区分<span class="number">13</span>和<span class="number">05</span>编译的版本，分别连接。
</code></pre><p>还有一个常见的warming：</p>
<pre><code>warning MSB8012: TargetPath xxx does <span class="keyword">not</span> match the <span class="keyword">Library</span><span class="attribute">'s</span> OutputFile <span class="keyword">property</span> value xxx
原因是General的Output Directory 和 Link 的 OutPut <span class="keyword">File</span> 输出文件路径不一致。
推荐在ganeral的Output Directory 写上你想要输出的路径，
然后在Link的OutPutFile 填上$(OutDir)$(TargetName)$(TargetExt)，如果需要改变也只需要改一处。
</code></pre><p>历尽千辛万苦终于搞好了client的编译，自己测试一下暂时没发现啥问题，但是还是得经过严密的测试才能发布出去，比如跨平台可能出现的问题。<br>对了，关于MFC库缺失的问题，我们并不是全部连接静态库的做法，而是把需要的库文件打包在游戏安装包里，数M的dll库相对数G的客户端来说，不算什么的。</p>
<p>接下来是server。<br>server关联的工程并不多，而且大部分坑在编译client的时候已经遇到过，所以整个编译过程还算顺利，但是测试的时候发现登录的时候会宕机。<br>调试了一下，发现是一个比较隐晦的STL的问题，直接上测试代码吧：</p>
<pre><code><span class="comment">#include &lt;stdio.h&gt;</span>
<span class="comment">#include &lt;vector&gt;</span>

typedef std::vector&lt;<span class="type">int</span>&gt; <span class="type">TEST_V</span>;

class <span class="type">TEST_C</span>
{
public:
    <span class="type">TEST_V</span> t_v;
    <span class="keyword">const</span> <span class="type">TEST_V</span>&amp; <span class="type">GetVR</span>() <span class="keyword">const</span> { <span class="keyword">return</span> t_v; };
};

<span class="type">int</span> main()
{
    <span class="type">TEST_C</span> c;
    memset(&amp;c, <span class="number">0</span>, sizeof(c)); // vector不能被memset！
    <span class="keyword">const</span> <span class="type">TEST_V</span>&amp; <span class="keyword">ref</span> = c.<span class="type">GetVR</span>();
    <span class="keyword">for</span> (<span class="type">TEST_V</span>::const_iterator it = <span class="keyword">ref</span>.begin(); it != <span class="keyword">ref</span>.<span class="keyword">end</span>(); ++it){}
    system(<span class="string">"pause"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>跟进去发现_Myproxy为NULL，说明vector的结构已经被破坏了：</p>
<pre><code><span class="keyword">const</span> _Container_base12 *_Getcont() <span class="keyword">const</span>
{    // get owning container
<span class="keyword">return</span> (_Myproxy == <span class="number">0</span> ? <span class="number">0</span> : _Myproxy-&gt;_Mycont);
}

<span class="comment">#if _ITERATOR_DEBUG_LEVEL == 2</span>
<span class="type">void</span> _Compat(<span class="keyword">const</span> _Myiter&amp; _Right) <span class="keyword">const</span>
    {    // test <span class="keyword">for</span> compatible <span class="keyword">iterator</span> pair
    <span class="keyword">if</span> (this-&gt;_Getcont() == <span class="number">0</span>
        || this-&gt;_Getcont() != _Right._Getcont())
        {    // report error
        _DEBUG_ERROR(<span class="string">"vector iterators incompatible"</span>);
        _SCL_SECURE_INVALID_ARGUMENT;
        }
    }

 <span class="comment">#elif _ITERATOR_DEBUG_LEVEL == 1</span>
    <span class="type">void</span> _Compat(<span class="keyword">const</span> _Myiter&amp; _Right) <span class="keyword">const</span>
        {    // test <span class="keyword">for</span> compatible <span class="keyword">iterator</span> pair
        _SCL_SECURE_VALIDATE(this-&gt;_Getcont() != <span class="number">0</span>);
        _SCL_SECURE_VALIDATE_RANGE(this-&gt;_Getcont() == _Right._Getcont());
        }

 <span class="comment">#else /* _ITERATOR_DEBUG_LEVEL == 0 */</span>
    <span class="type">void</span> _Compat(<span class="keyword">const</span> _Myiter&amp;) <span class="keyword">const</span>
        {    // test <span class="keyword">for</span> compatible <span class="keyword">iterator</span> pair
        }
 <span class="comment">#endif /* _ITERATOR_DEBUG_LEVEL */</span>
</code></pre><p>更为隐蔽的是，release版本不会有这个异常。而在vs2005上，不管debug,release都不会有异常（因为版本不一致）。<br>这样的写法肯定是存在问题的，还好这次发现了，也可以改下。</p>
<hr>
<h2 id="最后">最后</h2><p>最终的结果是，改动了7处代码，每个solution和proj都有对应的2013的版本，只需要把新加的这部分入库管理就好了。之后想用13开发的同事打开xx2013.sln，还继续想用05的打开原来的sln。<br>但是有一个不好的地方在于，<strong>新加文件或者工程会比较麻烦，得两种solution都要加上</strong>。</p>
<h3 id="未解决的问题：">未解决的问题：</h3><p>还需要修改我们的版本发布工具链，因为我们要发布出去的程序都有一套编译机来进行编译，现在只能说能让我们开发的时候用到。还不能发布给用户使用。不过呢，这个过程还需慢慢推进，为了稳(mei)定(you)性(bug)。<br>client只需要在对应的编译机上安装vs2013，然后改一下编译工具应该就好了的。而真正难搞的问题是linux的编译。我们的linux编译工具是根据自己写的一套根据vcproj文件生成的规则的文件生成的。由于05到13的工程文件变化比较大，修改这部分又是一个体力活了。索性就还是不改，只要保留着原来的05的proj，linux的编译就不会有问题。</p>
<p>stack overflow和msdn在这次过程中帮了大忙，很多琐碎的问题都在上面有了解答。</p>
<p>最最后，想说一下自己上面写的东西好啰嗦呵呵呵。文字表达能力越来越退化了。所以得坚持写blog下去！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于历史的原因，项目一直在使用vs2005进行开发，据说其他老一点的游戏项目很多也用05的，包括WOW，大概是因为05年正好是端游最火爆时期吧。<br>但是都过去10年了，是时候拥抱一下新的东西了:D。</p>
<p>最近不是很忙，就把之前一直想做的这件事情做了。花了两周的时间，算是基本升级完成了。<br>升级的过程中遇到各种问题，还是挺有意思的。</p>]]>
    
    </summary>
    
      <category term="work" scheme="http://frozenmoon.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UI编辑器优化]]></title>
    <link href="http://frozenmoon.github.io/2015/07/21/ui%E7%BC%96%E8%BE%91%E5%99%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://frozenmoon.github.io/2015/07/21/ui编辑器优化/</id>
    <published>2015-07-21T09:20:43.000Z</published>
    <updated>2015-08-04T08:41:44.159Z</updated>
    <content type="html"><![CDATA[<h2 id="说点什么吧">说点什么吧</h2><pre><code>最近项目也挺忙的，一直想抽时间来改改我们项目的ui编辑器，只能用挤出来的时间来做了。
</code></pre><a id="more"></a>
<hr>
<h2 id="改造目的">改造目的</h2><ul>
<li>提高开发效率</li>
<li>在尽可能少改动的前提下，解决热点需求即可</li>
</ul>
<hr>
<h2 id="ui编辑器简介">ui编辑器简介</h2><p>   年纪大概6，7年了吧。应该在出生后就没怎么改进过。MFC写的DLL，嵌入到游戏客户端中使用。<br>   好在有MFC基础，代码看起来挺亲切的:D<br>   需求完全是靠自己去想，平时用的时候有什么不爽的地方重要可以改掉，也可以过过PM的瘾。</p>
<hr>
<h2 id="改造点">改造点</h2><ol>
<li><p>界面布局调整</p>
</li>
<li><p>ui列表界面：根据首字母进行排序显示，搜索功能</p>
</li>
<li><p>新建ui窗口流程简化： 一键生成，默认模版（对应的：一键删除）</p>
</li>
<li><p>新建控件优化：默认控件模版</p>
</li>
<li><p>编辑器模式下控件默认可拖动</p>
</li>
<li><p>主窗口的相对位置</p>
</li>
</ol>
<hr>
<h2 id="解决方案">解决方案</h2><p>1.ui列表界面：原来的设计只是简单的读取ui列表，放入ListView中</p>
<ul>
<li><p>痛点：列表显示非常杂乱，且没有排序规则</p>
<blockquote>
<p>根据首字母进行排序：CListView.SortItem 搞定。</p>
</blockquote>
</li>
<li><p>痛点：没有搜索功能，要查找某个ui的时候只能靠人肉！</p>
<blockquote>
<p>搜索优化：最初的想法是加入一个edit，在输入变化的时候自动选中对应的item项。但是在尝试做了之后发现几个问题：<br>ListView的选中功能实在太弱，并且需要具有焦点的时候才能选中（有总是选中的属性，但是不符合需求），尝试未果之后考虑有没有其他的方式。<br>最后决定用动态删减ListViewItem的方式来解决这个问题：每次输入变化的时候，清空ListView，遍历ui列表，insert符合要求的ui。</p>
</blockquote>
</li>
<li><p>痛点：由于加入搜索功能，dlg打开的时候焦点默认给到edit：</p>
<blockquote>
<p>细节更闪亮:D</p>
</blockquote>
</li>
</ul>
<p>2.新建窗口</p>
<ul>
<li><p>痛点：之前添加一个ui非常麻烦，要手动添加很多东西，而且是程序自己来干这个事情，费时费力。</p>
<blockquote>
<p>在编辑器提供一键创建窗口，可以让策划或者ui设计师来制作ui。<br>基本都是字符串和文件操作，由于原有的体系比较繁杂，有部分硬编码，健壮性稍差。</p>
</blockquote>
</li>
<li><p>痛点：既然有生成就要对应删除</p>
<blockquote>
<p>就是生成过程的反过程，编码比较“硬”，纯属体力活了。</p>
</blockquote>
</li>
</ul>
<p>3.新建控件默认模版：</p>
<ul>
<li>痛点1：创建后没有默认参数！比如创建一个按钮，还有手动去改大小，图片，颜色等，非常麻烦。<blockquote>
<p>给各个控件配置默认的模版参数，这样只需要稍做修改就能完成需求。（每种控件都对应一个配置lua脚本）</p>
</blockquote>
</li>
</ul>
<p>4.可拖动控件</p>
<ul>
<li>痛点：不能拖动控件的编辑器怎么能叫编辑器！我们之前还用了好几年ORZ。<blockquote>
<p>当用编辑器打开窗口后，设置控件的可移动属性为true即可。问题在于我们的ui控件都是自己写的一套，所以有些控件并不支持窗口的移动。<br>只能改动各种控件的消息处理代码了。</p>
</blockquote>
</li>
</ul>
<p>5.窗口的动态停靠位置（Dock）</p>
<ul>
<li>痛点：以前我们客户端的窗口大小是固定4个模式的，不同模式下的窗口位置定义都是写死的！大约1年前，改成了客户端可以自由改变大小，但编辑器没有对应的更新。<blockquote>
<p>编辑器可改变DockType，x,y 的偏移量。做到所见即所得。</p>
</blockquote>
</li>
</ul>
<p>n.其他细节</p>
<ul>
<li>打开ui后，控件树默认展开Main项。</li>
<li>处理了发现的遗留的bug</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="说点什么吧">说点什么吧</h2><pre><code>最近项目也挺忙的，一直想抽时间来改改我们项目的ui编辑器，只能用挤出来的时间来做了。
</code></pre>]]>
    
    </summary>
    
      <category term="program" scheme="http://frozenmoon.github.io/tags/program/"/>
    
      <category term="work" scheme="http://frozenmoon.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo 使用之路]]></title>
    <link href="http://frozenmoon.github.io/2015/05/11/%E8%AF%BB%E8%AF%BB%E5%86%99%E5%86%99/"/>
    <id>http://frozenmoon.github.io/2015/05/11/读读写写/</id>
    <published>2015-05-11T11:20:43.000Z</published>
    <updated>2015-07-21T10:19:55.127Z</updated>
    <content type="html"><![CDATA[<p>记录使用hexo的技巧</p>
<a id="more"></a>
<h2 id="图片">图片</h2><p><img src="images/cat.jpg" alt=""></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录使用hexo的技巧</p>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://frozenmoon.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello  World]]></title>
    <link href="http://frozenmoon.github.io/2015/05/11/hello-world/"/>
    <id>http://frozenmoon.github.io/2015/05/11/hello-world/</id>
    <published>2015-05-11T09:20:43.000Z</published>
    <updated>2015-05-11T11:24:20.868Z</updated>
    <content type="html"><![CDATA[<p>4个月前用hexo部署了自己的第一个博客，期间一直忙着项目（lan）。<br>现在终于可以开始了。<br>最近想做的太多，但做的太少，这里希望是一个好的开始。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>4个月前用hexo部署了自己的第一个博客，期间一直忙着项目（lan）。<br>现在终于可以开始了。<br>最近想做的太多，但做的太少，这里希望是一个好的开始。</p>
]]>
    </summary>
    
      <category term="mix" scheme="http://frozenmoon.github.io/tags/mix/"/>
    
  </entry>
  
</feed>